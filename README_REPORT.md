# ОТЧЁТ О РАБОТЕ ПРОГРАММЫ

## 1. Очистка и подготовка данных

### Используемые функции:
- `clean_movies()`
- `clean_tags()`
- `clean_ratings()`

Данные функции, импортируемые из модуля `scripts.data_cleaning`, выполняют предварительную очистку данных. Они удаляют дубликаты, пропущенные значения и производят приведение данных к корректному формату. Для повышения производительности они запускаются параллельно с использованием многопоточности через `ThreadPoolExecutor`.

### Стандартизация данных
После очистки данных я их стандартизирую при помощи`standardize_data`. Это позволяет привести значения рейтингов к единому масштабу, чтобы в дальнейшем с этими данными было удобно работать используя алгоритмы машинного обучения.

Обработанные и стандартизированные данные сохраняются в директорию `output` в формате CSV.

---

## 2. Визуализация данных

Используются функции из модуля `scripts.data_visualization`, включая:
- `plot_correlation_matrix`
- `plot_rating_distribution`
- `plot_user_ratings_distribution`
- `plot_genre_ratings`
- `plot_ratings_over_time`
- `plot_cluster_distribution`

Назначение данных функций — визуальное представление характеристик датасета, распределения рейтингов и пользователей, а также распределения фильмов по кластерам. Данные графики были созданы как для большего понимая данных, я которыми я работаю, так и для последующего анализа данных.

---

## 3. Кластеризация фильмов

### Подготовка признаков
Функция `create_movie_features(movies_df, ratings_df, tags_df)` формирует числовые признаки на основе:
- Жанров ( с применением `One-Hot encoding` (это метод, который позволяет представлять категориальные переменные в виде числовых значений для использования в моделях машинного обучения.)),
- Средних рейтингов фильмов,
- Тегов.

Данные признаки служат входом для алгоритма кластеризации.

### Алгоритмы кластеризации
Программа применяет алгоритмы:
- `KMeans` 
- `MiniBatchKMeans` 

`KMeans` — начальный анализ, разбивка по жанрам, используется для проверки и понимания жанровой структуры.
`MiniBatchKMeans` — финальная кластеризация с учетом всех признаков, используется для построения рекомендательной системы.
Разделение задач между алгоритмами позволяет повысить точность анализа и оптимизировать использование ресурсов.

`KMeans (кластеризация по жанрам)`
Используется в функции `train_kmeans`. Работает только с жанрами фильмов. Применяется `One-Hot Encoding` к жанрам, далее данные масштабируются. Модель обучается на этих признаках, каждому фильму присваивается номер кластера. Основная цель — быстро получить начальное разделение фильмов по тематике.
Результаты сохраняются в `movies_df["cluster"]`
2. `MiniBatchKMeans` + `PCA` (кластеризация по всем признакам)
Используется в функции `perform_clustering`.
Работает с расширенными признаками: жанры, рейтинги, теги и другие числовые характеристики.
Перед кластеризацией применяется `PCA` для уменьшения размерности (сохраняется 95% дисперсии).
`MiniBatchKMeans` используется как более производительный алгоритм, подходящий для больших объемов данных.
Основная цель — создать более точные и устойчивые кластеры для последующего использования в рекомендациях.
Результаты сохраняются:
Файл `output/clusters_movies.csv` — фильмы и их кластеры.
Файл `output/kmeans_model.pkl` — обученная модель.


Пример вызова:
```python
movies_df, kmeans = perform_clustering(movie_features, movies_df, n_clusters=10)
```

### Механизм кластеризации:
1. Инициализация центров кластеров.
2. Назначение фильмов ближайшему кластеру по евклидовому расстоянию.
3. Перерасчёт центров кластеров.
4. Повторение процесса до сходимости.

Каждому фильму присваивается метка кластера (`cluster`), которая сохраняется в результирующем DataFrame.

---

## 4. Анализ кластеров

Используются функции из модуля `scripts.cluster_analysis`, включая:
- `analyze_cluster_distribution`
- `analyze_genres_by_cluster`
- `analyze_ratings_by_cluster`
- `popular_genres_in_clusters`
- `compare_clusters`
- `filter_top_movies`
- `get_top_movies_in_clusters`
- `analyze_sentiment`

Функции анализируют состав кластеров, жанровое распределение, рейтинги, популярные фильмы и производят анализ тональности тегов.

---

## 5. Рекомендации фильмов

### Рекомендации на основе тегов
Функция `recommend_by_tags(movie_id, df)` реализует поиск фильмов, схожих с заданным фильмом по тегам, в рамках одного кластера. (предполагаю, что эту функцию надо еще доработать для более точной работы)

Механизм:
1. Определяется кластер фильма.
2. Извлекаются теги фильма.
3. В рамках кластера ищутся фильмы с максимально схожими тегами.
4. Сходство вычисляется как отношение пересечения тегов к их объединению.

Функция возвращает топ-5 фильмов с наибольшим сходством.

---

## 6. Определение предпочтений пользователя

Функция `get_favorite_cluster(user_id, ratings_df, movies_df)` определяет наиболее предпочтительный кластер пользователя на основе его истории оценок. (Надо доработать)

Механизм:
1. Определение фильмов, оценённых пользователем.
2. Подсчёт количества фильмов в каждом кластере.
3. Возврат кластера с наибольшим количеством оценок.

---

## 7. Сохранение результатов

Используются функции:
- `save_dataframe(movies_df, "clusters_movies.csv")` — сохранение фильмов с кластеризацией.

---

## 8. Дополнительная обработка тегов

Функция `generate_sorted_tags_by_cluster(input_csv, output_csv)` подсчитывает частоту появления тегов в каждом кластере и сохраняет результаты в сжатом формате.

---

### Индивидуальный подбор фильма для пользователя

(Как раз то, что план рую доработать в ближайшее время )
На текущий момент реализована только функция определения любимого кластера пользователя. Однако рекомендация фильмов с учётом индивидуальных предпочтений отсутствует.

### Как реализовать персонализированные рекомендации:

1. **Определить любимый кластер пользователя**:
   ```python
   favorite_cluster = get_favorite_cluster(user_id, ratings_df, movies_df)
   ```

2. **Получить список фильмов, которые пользователь уже оценил**:
   ```python
   user_rated_movies = ratings_df[ratings_df['userId'] == user_id]['movieId'].unique()
   ```

3. **Выбрать фильмы из любимого кластера, которые пользователь ещё не смотрел**:
   ```python
   candidate_movies = movies_df[
       (movies_df['cluster'] == favorite_cluster) &
       (~movies_df['movieId'].isin(user_rated_movies))
   ]
   ```

4. **Отсортировать по средней оценке и выбрать топ-N**:
   ```python
   avg_ratings = ratings_df.groupby('movieId')['rating'].mean()
   candidate_movies = candidate_movies.assign(avg_rating=candidate_movies['movieId'].map(avg_ratings))
   recommended_movies = candidate_movies.sort_values('avg_rating', ascending=False).head(5)
   ```

